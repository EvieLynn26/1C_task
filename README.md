# 1C_task

Код задачи: 141

Пасьянс.

Две колоды карт (по 36 штук) соединяются и перемешиваются, а после раскладываются в 8 кучек по 9 карт. 

Можно работать только с верхними картами в каждой из кучек, а именно перекладывать одну или несколько последовательных карт меньшего номинала на карту большего (масти не учитываются). 
Если в одной из кучек оказалось 9 карт в правильном порядке (Напомню, туз-король-дама-валет-10-9-8-7-6), то этот набор убирается. 
Если из одной кучки убрали все карты, её всё ещё можно использовать и класть наверх любую карту. 
Необходимо реализовать программу, которая по информации об исходном состоянии восьми кучек посчитает, можно ли будет убрать все карты.

## Описание алгоритма решения
Отметим несколько свойств, которые могут помочь  в решении:
* как только образовалась последовательность открытых карт, разъединять ее (использовать ее суффиксы) нет смысла, т.к. это приводит к эквивалентным ситуациям, поэтому храним только верх и низ открытой кучки
* храним закрытые карты стеке, чтобы легко получать текущую карту, которую можно открыть
* в качестве типа данных для достоинств карт и номеров стопок можно использловать uint8_t, т.к. эти значения небольшие и всегда неотрицательные

Для решения воспользуемся жадным алгоритмом, который будет пытаться разложить пасьянс, принимая локально более выгодные решения, зная ситуацию на столе. По условию задачи нам известны достоинтсва всех закрытых карт. Будем искать для каждой кучки A кучку-"донора" -- кучку B, которую можно положить на A. При убирании B со своего места, откроется новая карта (если еще есть запас) (за счет первого свойства). Жадный алгоритм заключается в том, чтобы брать кучки B так, чтобы открывались выгодные новые карты: которые можем использовать уже в следующий ход. Для этого в двух сетах храним достоинтсва карт, которые можно положить вниз или на которые можно положить уже собранную стопку. Возникает две нехороших ситуации, которые нужно проверять отдельно: 1. проблема "затирания" доступного места (низ стопки A), чтобы положить открывшуюся карту, стопкой B, которую и положим вниз стопки A. 2. проблема, если единственное применение открывшейся карты -- стать началом стопки B, плохо, потому что по правилам не можем же снять-открыть-положить туда же.

Обработка всех кучек заключается итеративном поиске для каждой кучки наилучшего "донора" и перекладывания этого донора на нее (перекладываение заключается в изменении полей upper_value, lower_value и стека у объектов класса pile). Процесс продолжаем, пока не откроем все закрытые и не проверим, сошелся ли пасьянс.

Не успела написать ввод данных, это была бы инициализация классов кучек и стола, где в upper_value, lower_value лежало бы одно и то же значение -- достоинство нижней карты, остальные закрытые карты помещались бы в стек, чтобы вершина была на первой доступной к открыванию карте (ввод данных был бы по кучкам, от верхней к нижней в стек, последнюю карту в upper_value и lower_value).
